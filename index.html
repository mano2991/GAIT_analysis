<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gait Analysis Visualization Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .container { max-width: 1400px; }
        .panel { background-color: #ffffff; border: 1px solid #e2e8f0; }
        .header { background-color: #1e293b; color: #f8fafc; }
        .panel h2 { color: #1e293b; border-bottom: 1px solid #e2e8f0; }
        .upload-area { border: 2px dashed #cbd5e1; }
        .upload-area:hover { border-color: #4f46e5; background-color: #f8fafc; }
        .form-group label { color: #334155; }
        .form-group input, .form-group select { border: 1px solid #cbd5e1; border-radius: 0.5rem; padding: 0.6rem 0.8rem; background-color: #f8fafc; transition: border-color 0.2s, box-shadow 0.2s; }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: #4f46e5; box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.15); }
        .btn { background-color: #4f46e5; color: white; border: none; border-radius: 0.5rem; font-weight: 600; transition: background-color 0.2s ease-in-out, transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; }
        .btn:hover { background-color: #4338ca; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2); }
        .btn:disabled { background-color: #94a3b8; cursor: not-allowed; transform: none; box-shadow: none; }
        .btn-success { background-color: #16a34a; }
        .btn-success:hover { background-color: #15803d; box-shadow: 0 4px 12px rgba(22, 163, 74, 0.2); }
        .color-picker input[type="color"] { -webkit-appearance: none; width: 32px; height: 32px; border: 1px solid #e2e8f0; border-radius: 50%; padding: 0; cursor: pointer; }
        .color-picker input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; border-radius: 50%; }
        .color-picker input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
        .status.success { background-color: #f0fdf4; color: #15803d; border: 1px solid #bbf7d0; border-radius: 0.5rem; }
        .status.error { background-color: #fef2f2; color: #b91c1c; border: 1px solid #fecaca; border-radius: 0.5rem; }
        .status.info { background-color: #eff6ff; color: #1d4ed8; border: 1px solid #bfdbfe; border-radius: 0.5rem; }
        .spinner { width: 1.25rem; height: 1.25rem; border: 2px solid transparent; border-top: 2px solid currentColor; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .download-options { background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.75rem; padding: 1rem; margin-top: 1rem; }
        .dpi-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; border-radius: 4px; background: linear-gradient(to right, #e2e8f0 0%, #4f46e5 0%); outline: none; position: relative; }
        .dpi-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #4f46e5; cursor: pointer; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .slider-container { position: relative; margin: 0.5rem 0; }
        .slider-labels { display: flex; justify-content: space-between; font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; }
        #plot-container { position: relative; width: 100%; cursor: pointer; }
        #hover-canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        #tooltip { position: absolute; background-color: rgba(2, 6, 23, 0.8); color: white; padding: 4px 8px; font-size: 12px; border-radius: 4px; pointer-events: none; display: none; transform: translate(-50%, -150%); }
    </style>
</head>
<body>
    <div class="container mx-auto my-8 bg-white rounded-2xl shadow-2xl overflow-hidden border border-gray-200">
        <div class="header p-8 text-center">
            <h1 class="text-4xl font-bold tracking-tight">Gait Analysis Visualization Tool</h1>
            <p class="text-lg text-slate-300 mt-2">Generate high-quality static plots from your DLC data</p>
        </div>

        <div class="content flex flex-col lg:flex-row gap-8 p-8">
            <div class="controls-panel lg:w-1/3 space-y-6">
                <div class="panel rounded-xl p-6">
                    <h2 class="text-xl font-semibold pb-4 mb-4">üìÅ File Upload</h2>
                    <div class="upload-area rounded-lg p-10 text-center cursor-pointer" id="uploadArea">
                        <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                        <p class="mt-2 text-sm text-gray-600">Click to upload or drag & drop</p>
                        <p class="text-xs text-gray-500">CSV files only</p>
                        <input type="file" id="csvFile" accept=".csv" class="hidden">
                    </div>
                    <div id="fileStatus" class="mt-4"></div>
                </div>

                <div class="panel rounded-xl p-6">
                    <h2 class="text-xl font-semibold pb-4 mb-4">‚öôÔ∏è Plot Styling</h2>
                    <div class="form-group mb-4">
                        <label class="text-sm font-medium">Plot Title</label>
                        <input type="text" id="plotTitle" value="Gait Analysis Plot" class="mt-1 w-full">
                    </div>
                    <div class="grid grid-cols-2 gap-4 form-group mb-4">
                         <div><label class="text-sm font-medium">X-Axis Label</label><input type="text" id="xAxisLabel" value="X - Coordinate" class="mt-1 w-full"></div>
                         <div><label class="text-sm font-medium">Y-Axis Label</label><input type="text" id="yAxisLabel" value="Y - Coordinate" class="mt-1 w-full"></div>
                    </div>

                    <div class="form-group mb-4">
                        <label class="text-sm font-medium">Plot Background Color</label>
                        <div class="color-picker text-sm flex items-center mt-1">
                            <span>Background Color:</span>
                            <input type="color" id="plotBackgroundColor" value="#ffffff" class="ml-auto">
                        </div>
                    </div>
                    
                    <div class="form-group mb-4 border-t pt-4">
                        <label class="text-sm font-bold block mb-2">Highlighted Frame Style</label>
                        <div class="grid grid-cols-3 gap-4">
                            <div><label class="text-xs font-medium text-gray-600">Point Size</label><input type="number" id="pointSize" value="8" class="mt-1 w-full"></div>
                            <div><label class="text-xs font-medium text-gray-600">Line Width</label><input type="number" id="lineWidth" value="5" class="mt-1 w-full"></div>
                            <div><label class="text-xs font-medium text-gray-600">Text Size</label><input type="number" id="textSize" value="14" class="mt-1 w-full"></div>
                        </div>
                    </div>
                    
                    <div class="form-group mb-4">
                        <label class="text-sm font-medium">Body Part Colors</label>
                        <div class="grid grid-cols-2 gap-x-6 gap-y-4 mt-2">
                            <div class="color-picker text-sm flex items-center"><span>Toe:</span><input type="color" id="colorToe" value="#F781BF" class="ml-auto"></div>
                            <div class="color-picker text-sm flex items-center"><span>MTP:</span><input type="color" id="colorMtp" value="#FDB462" class="ml-auto"></div>
                            <div class="color-picker text-sm flex items-center"><span>Ankle:</span><input type="color" id="colorAnkle" value="#B3ED69" class="ml-auto"></div>
                            <div class="color-picker text-sm flex items-center"><span>Knee:</span><input type="color" id="colorKnee" value="#80B1D3" class="ml-auto"></div>
                            <div class="color-picker text-sm flex items-center"><span>Hip:</span><input type="color" id="colorHip" value="#CAB2D6" class="ml-auto"></div>
                            <div class="color-picker text-sm flex items-center"><span>Iliac:</span><input type="color" id="colorIliac" value="#F90B0B" class="ml-auto"></div>
                        </div>
                    </div>

                    <div class="form-group mb-4 border-t pt-4">
                        <label class="text-sm font-bold block mb-2">Background / Unselected Frames</label>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="text-xs font-medium text-gray-600">Color</label>
                                <div class="color-picker text-sm flex items-center mt-1">
                                    <span>Frame Color:</span>
                                    <input type="color" id="backgroundFrameColor" value="#94a3b8" class="ml-auto">
                                </div>
                            </div>
                            <div>
                                <label class="text-xs font-medium text-gray-600">Opacity</label>
                                <input type="range" id="backgroundOpacity" min="0" max="100" value="10" class="w-full mt-1">
                                <div class="text-xs text-center text-gray-600" id="opacityValue">10%</div>
                            </div>
                        </div>
                        <div class="mt-4">
                            <label class="text-sm font-medium text-gray-700">Frame Step</label>
                            <input type="number" id="frameStep" value="1" min="1" class="w-full mt-1">
                            <p class="text-xs text-gray-500 mt-1">Draw one background frame every N steps to reduce clutter.</p>
                        </div>
                    </div>
                    
                    <div class="form-group mb-4 border-t pt-4">
                        <label class="text-sm font-bold block mb-2">General Settings</label>
                        <div class="mb-4">
                            <label class="text-sm font-medium">Labels & Title Color</label>
                            <div class="color-picker text-sm flex items-center mt-1">
                                <span>Text Color:</span>
                                <input type="color" id="textColor" value="#1e293b" class="ml-auto">
                            </div>
                        </div>
                        <label class="text-sm font-medium">Likelihood Threshold</label>
                        <input type="number" id="threshold" value="0.5" min="0" max="1" step="0.1" class="w-full mt-1">
                    </div>
                    
                    <div class="form-group mb-4 border-t pt-4">
                        <label class="text-sm font-bold mb-3 block">Download Options</label>
                        <div class="download-options">
                            <div class="grid grid-cols-2 gap-4 mb-4">
                                <div>
                                    <label class="text-xs font-medium text-gray-600 mb-2 block">DPI Quality</label>
                                    <div class="slider-container">
                                        <input type="range" id="dpiSlider" min="100" max="600" value="300" step="50" class="dpi-slider">
                                        <div class="slider-labels"><span>100</span><span>600</span></div>
                                    </div>
                                    <div class="text-center text-sm font-semibold text-gray-700 mt-1" id="dpiValue">300 DPI</div>
                                </div>
                                <div>
                                    <label class="text-xs font-medium text-gray-600 mb-1 block">Background</label>
                                    <select id="backgroundType" class="w-full text-sm">
                                        <option value="white">White Background</option>
                                        <option value="black">Black Background</option>
                                        <option value="transparent">Transparent Background</option>
                                    </select>
                                </div>
                            </div>
                            <div class="text-xs text-gray-500 mb-2"><span id="imageSizeInfo">Image size: ~2400 x 2100 pixels</span></div>
                        </div>
                    </div>

                    <div class="mt-6">
                        <button class="btn w-full text-base py-3 btn-success" id="downloadBtn" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
                            Generate Downloadable PNG
                        </button>
                    </div>
                </div>
            </div>

            <div class="results-panel lg:w-2/3 flex flex-col">
                <div class="panel rounded-xl p-6 flex-grow flex flex-col">
                    <h2 class="text-xl font-semibold pb-4 mb-4">üìä Interactive Plot</h2>
                    <p class="text-sm text-slate-500 -mt-4 mb-4">Hover to see frame number. Click on any stick figure to select or deselect it.</p>
                    <div id="processingStatus"></div>
                    <div id="results" class="flex-grow flex justify-center items-center bg-slate-100 rounded-lg min-h-[300px] lg:min-h-0 p-4">
                        <p class="text-gray-500">Upload a CSV file to begin</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let csvData = null;
        let allNormalizedPoints = [];
        let selectedFrames = [];

        const uploadArea = document.getElementById('uploadArea');
        const csvFile = document.getElementById('csvFile');
        const fileStatus = document.getElementById('fileStatus');
        const downloadBtn = document.getElementById('downloadBtn');
        const processingStatus = document.getElementById('processingStatus');
        const results = document.getElementById('results');
        const backgroundOpacitySlider = document.getElementById('backgroundOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const dpiSlider = document.getElementById('dpiSlider');
        const dpiValue = document.getElementById('dpiValue');
        const imageSizeInfo = document.getElementById('imageSizeInfo');
        
        document.addEventListener('DOMContentLoaded', function() {
            uploadArea.addEventListener('click', () => csvFile.click());
            csvFile.addEventListener('change', (e) => processFile(e.target.files[0]));
            downloadBtn.addEventListener('click', generateDownloadableImage);
            
            const immediateRefreshControls = [
                backgroundOpacitySlider,
                document.getElementById('backgroundFrameColor'),
                document.getElementById('textColor'),
                document.getElementById('pointSize'),
                document.getElementById('lineWidth'),
                document.getElementById('plotTitle'),
                document.getElementById('xAxisLabel'),
                document.getElementById('yAxisLabel'),
                document.getElementById('frameStep'),
                document.getElementById('plotBackgroundColor'), // Add new control to the list
            ];
            immediateRefreshControls.forEach(control => {
                control.addEventListener('input', () => { if (csvData) generateInteractivePlot(); });
            });
            backgroundOpacitySlider.addEventListener('input', () => {
                opacityValue.textContent = `${backgroundOpacitySlider.value}%`;
            });
            
            dpiSlider.addEventListener('input', function() {
                const dpi = parseInt(this.value);
                dpiValue.textContent = `${dpi} DPI`;
                imageSizeInfo.textContent = `Image size: ~${dpi * 8} x ${dpi * 7} pixels`;
            });
            dpiValue.textContent = `${dpiSlider.value} DPI`;
            imageSizeInfo.textContent = `Image size: ~${dpiSlider.value * 8} x ${dpiSlider.value * 7} pixels`;
        });

        function generateInteractivePlot() { /* ... Unchanged ... */ }
        function generateDownloadableImage() { /* ... Unchanged ... */ }
        
        // MODIFIED: Unified plotting function to handle background colors
        function generatePlotCanvas(options) {
            const { isForDownload } = options;
            
            const displayWidth = 800;
            const displayHeight = 700;
            const dpi = parseInt(document.getElementById('dpiSlider').value);

            const canvas = document.createElement('canvas');
            canvas.width = isForDownload ? dpi * 8 : displayWidth;
            canvas.height = isForDownload ? dpi * 7 : displayHeight;
            const scaleFactor = canvas.width / displayWidth;
            const ctx = canvas.getContext('2d');
            
            const downloadBackgroundType = document.getElementById('backgroundType').value;
            const interactiveBackgroundColor = document.getElementById('plotBackgroundColor').value;
            const textColor = document.getElementById('textColor').value;
            const plotTitle = document.getElementById('plotTitle').value;
            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;
            const frameStep = parseInt(document.getElementById('frameStep').value) || 1;

            // Handle background color logic
            if (isForDownload) {
                if (downloadBackgroundType === 'white') {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else if (downloadBackgroundType === 'black') {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                // For 'transparent', we do nothing.
            } else {
                // For the interactive on-screen canvas, use the color picker value.
                ctx.fillStyle = interactiveBackgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            const allPointsForBounds = allNormalizedPoints.filter(p => p).flat().flatMap(p => Object.values(p));
            if (allPointsForBounds.length === 0) throw new Error('No valid points found to plot.');

            const minX = Math.min(...allPointsForBounds.map(p => p.x));
            const maxX = Math.max(...allPointsForBounds.map(p => p.x));
            const minY = Math.min(...allPointsForBounds.map(p => p.y));
            const maxY = Math.max(...allPointsForBounds.map(p => p.y));
            
            const padding = 100 * scaleFactor;
            const scale = Math.min((canvas.width - 2 * padding) / (maxX - minX || 1), (canvas.height - 2 * padding) / (maxY - minY || 1)) * 0.9;
            const offsetX = canvas.width / 2 - ((maxX + minX) / 2) * scale;
            const offsetY = (canvas.height - (120 * scaleFactor)) / 2 - ((maxY + minY) / 2) * scale;

            const backgroundFrameColor = document.getElementById('backgroundFrameColor').value;
            const backgroundOpacity = parseInt(document.getElementById('backgroundOpacity').value) / 100;
            const colors = { toe: document.getElementById('colorToe').value, mtp: document.getElementById('colorMtp').value, ankle: document.getElementById('colorAnkle').value, knee: document.getElementById('colorKnee').value, hip: document.getElementById('colorHip').value, iliac: document.getElementById('colorIliac').value };
            const highlightedLineWidth = parseInt(document.getElementById('lineWidth').value) * scaleFactor;
            const highlightedPointSize = parseInt(document.getElementById('pointSize').value) * scaleFactor;

            ctx.globalAlpha = backgroundOpacity;
            for (let i = 0; i < allNormalizedPoints.length; i += frameStep) {
                const points = allNormalizedPoints[i];
                if (points && !selectedFrames.includes(i)) {
                    drawStickFigure(ctx, points, scale, offsetX, offsetY, backgroundFrameColor, 1.5 * scaleFactor, null, 0);
                }
            }

            ctx.globalAlpha = 1.0;
            selectedFrames.forEach(frameIndex => {
                const points = allNormalizedPoints[frameIndex];
                if (points) {
                    drawStickFigure(ctx, points, scale, offsetX, offsetY, null, highlightedLineWidth, colors, highlightedPointSize);
                }
            });

            ctx.globalAlpha = 1.0;
            ctx.fillStyle = textColor;
            const baseTextSize = parseInt(document.getElementById('textSize').value);

            ctx.font = `bold ${(baseTextSize + 6) * scaleFactor}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(plotTitle, canvas.width / 2, 50 * scaleFactor);
            ctx.font = `${baseTextSize * scaleFactor}px Inter, sans-serif`;
            ctx.fillText(xAxisLabel, canvas.width / 2, canvas.height - (40 * scaleFactor));
            ctx.save();
            ctx.translate(50 * scaleFactor, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(yAxisLabel, 0, 0);
            ctx.restore();
            drawLegend(ctx, colors, canvas.width, canvas.height, highlightedPointSize, textColor, scaleFactor);
            
            const plotContext = isForDownload ? null : { scale: scale / scaleFactor, offsetX: offsetX / scaleFactor, offsetY: offsetY / scaleFactor };
            
            return { canvas, plotContext };
        }
        
        
        function handleCanvasHover(event, plotContext) { /* ... Unchanged ... */ }
        function handleCanvasClick(event, plotContext) { /* ... Unchanged ... */ }
        function findNearestFrame(mouseX, mouseY, plotContext) { /* ... Unchanged ... */ }
        function handleCanvasLeave() { /* ... Unchanged ... */ }
        function drawStickFigure(ctx, points, scale, offsetX, offsetY, overrideColor, lineWidth, pointColors = null, pointSize = 6) { /* ... Unchanged ... */ }
        function drawMarker(ctx, part, x, y, size) { /* ... Unchanged ... */ }
        function drawLegend(ctx, colors, canvasWidth, canvasHeight, pointSize, textColor, scaleFactor) { /* ... Unchanged ... */ }
        function setProcessing(processing, message = '') { /* ... Unchanged ... */ }
        function showStatus(type, message) { /* ... Unchanged ... */ }
        function processFile(file) { /* ... Unchanged ... */ }
        function parseCSV(csvText) { /* ... Unchanged ... */ }
        function processData() { /* ... Unchanged ... */ }
        function displayResults(displayCanvas, plotContext) { /* ... Unchanged ... */ }
        
        // --- Full versions of unchanged functions for completeness ---
        function generateInteractivePlot() {
            if (!csvData) return;
            const { canvas, plotContext } = generatePlotCanvas({ isForDownload: false });
            displayResults(canvas, plotContext);
        }
        function generateDownloadableImage() {
            setProcessing(true, 'Generating high-resolution image...');
            setTimeout(() => {
                try {
                    const { canvas } = generatePlotCanvas({ isForDownload: true });
                    const link = document.createElement('a');
                    link.download = 'gait_analysis_plot.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                } catch (error) {
                    console.error("Download failed:", error);
                } finally {
                    setProcessing(false);
                }
            }, 100);
        }
        function displayResults(displayCanvas, plotContext) {
            results.innerHTML = '';
            const plotContainer = document.createElement('div');
            plotContainer.id = 'plot-container';
            displayCanvas.style.maxWidth = '100%';
            displayCanvas.style.height = 'auto';
            displayCanvas.style.boxShadow = '0 4px 6px -1px rgba(0, 0, 0, 0.1)';
            displayCanvas.style.borderRadius = '0.5rem';
            const hoverCanvas = document.createElement('canvas');
            hoverCanvas.id = 'hover-canvas';
            hoverCanvas.width = displayCanvas.width;
            hoverCanvas.height = displayCanvas.height;
            hoverCanvas.style.maxWidth = '100%';
            hoverCanvas.style.height = 'auto';
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            plotContainer.append(displayCanvas, hoverCanvas, tooltip);
            results.appendChild(plotContainer);
            requestAnimationFrame(() => {
                const rect = displayCanvas.getBoundingClientRect();
                hoverCanvas.style.width = `${rect.width}px`;
                hoverCanvas.style.height = `${rect.height}px`;
                plotContainer.addEventListener('mousemove', e => handleCanvasHover(e, plotContext));
                plotContainer.addEventListener('mouseleave', handleCanvasLeave);
                plotContainer.addEventListener('click', e => handleCanvasClick(e, plotContext));
            });
        }
        function handleCanvasHover(event, plotContext) {
            const hoverCanvas = document.getElementById('hover-canvas');
            const tooltip = document.getElementById('tooltip');
            if (!hoverCanvas || !tooltip) return;
            const canvas = event.currentTarget.querySelector('canvas:not(#hover-canvas)');
            if (!canvas) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;
            const frameIndex = findNearestFrame(mouseX, mouseY, plotContext);
            const hoverCtx = hoverCanvas.getContext('2d');
            hoverCtx.clearRect(0, 0, hoverCanvas.width, hoverCanvas.height);
            if (frameIndex !== -1) {
                const points = allNormalizedPoints[frameIndex];
                const { scale, offsetX, offsetY } = plotContext;
                drawStickFigure(hoverCtx, points, scale, offsetX, offsetY, 'rgba(79, 70, 229, 0.5)', 3, null, 0);
                tooltip.style.display = 'block';
                tooltip.style.left = `${event.clientX - rect.left}px`;
                tooltip.style.top = `${event.clientY - rect.top}px`;
                tooltip.textContent = `Frame: ${frameIndex}`;
            } else {
                tooltip.style.display = 'none';
            }
        }
        function handleCanvasClick(event, plotContext) {
            const canvas = event.currentTarget.querySelector('canvas:not(#hover-canvas)');
            if (!canvas) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;
            const frameIndex = findNearestFrame(mouseX, mouseY, plotContext);
            if (frameIndex !== -1) {
                const indexInSelection = selectedFrames.indexOf(frameIndex);
                if (indexInSelection > -1) {
                    selectedFrames.splice(indexInSelection, 1);
                } else {
                    selectedFrames.push(frameIndex);
                }
                generateInteractivePlot();
            }
        }
        function findNearestFrame(mouseX, mouseY, plotContext) {
            const { scale, offsetX, offsetY } = plotContext;
            const dataX = (mouseX - offsetX) / scale;
            const dataY = (mouseY - offsetY) / scale;
            let bestMatch = { frameIndex: -1, distance: Infinity };
            allNormalizedPoints.forEach((points, frameIndex) => {
                if (!points) return;
                let minDistanceForThisFrame = Infinity;
                for (const partName in points) {
                    const partPoint = points[partName];
                    const dist = Math.hypot(partPoint.x - dataX, partPoint.y - dataY);
                    if (dist < minDistanceForThisFrame) { minDistanceForThisFrame = dist; }
                }
                if (minDistanceForThisFrame < bestMatch.distance) { bestMatch = { frameIndex, distance: minDistanceForThisFrame }; }
            });
            return bestMatch.distance < 20 ? bestMatch.frameIndex : -1;
        }
        function handleCanvasLeave() {
            const hoverCanvas = document.getElementById('hover-canvas');
            const tooltip = document.getElementById('tooltip');
            if (!hoverCanvas || !tooltip) return;
            hoverCanvas.getContext('2d').clearRect(0, 0, hoverCanvas.width, hoverCanvas.height);
            tooltip.style.display = 'none';
        }
        function drawStickFigure(ctx, points, scale, offsetX, offsetY, overrideColor, lineWidth, pointColors = null, pointSize = 6) {
            const segments = [['toe', 'mtp'], ['mtp', 'ankle'], ['ankle', 'knee'], ['knee', 'hip'], ['hip', 'iliac']];
            ctx.lineCap = 'round';
            ctx.lineWidth = lineWidth;
            segments.forEach(([part1, part2]) => {
                const p1 = points[part1], p2 = points[part2];
                if (p1 && p2) {
                    ctx.strokeStyle = overrideColor || (pointColors ? pointColors[part1] : 'black');
                    ctx.beginPath();
                    ctx.moveTo(p1.x * scale + offsetX, p1.y * scale + offsetY);
                    ctx.lineTo(p2.x * scale + offsetX, p2.y * scale + offsetY);
                    ctx.stroke();
                }
            });
            if (pointColors && pointSize > 0) {
                for (const part in points) {
                    if (pointColors[part]) {
                        ctx.fillStyle = ctx.strokeStyle = pointColors[part];
                        drawMarker(ctx, part, points[part].x * scale + offsetX, points[part].y * scale + offsetY, pointSize);
                    }
                }
            }
        }
        function drawMarker(ctx, part, x, y, size) {
            const s = size / 2;
            ctx.beginPath();
            switch (part) {
                case 'toe': ctx.arc(x, y, s, 0, 2 * Math.PI); ctx.fill(); break;
                case 'mtp': ctx.rect(x - s, y - s, size, size); ctx.fill(); break;
                case 'ankle': ctx.moveTo(x, y - s); ctx.lineTo(x + s, y); ctx.lineTo(x, y + s); ctx.lineTo(x - s, y); ctx.closePath(); ctx.fill(); break;
                case 'knee': ctx.moveTo(x, y - s); ctx.lineTo(x + s, y + s); ctx.lineTo(x - s, y + s); ctx.closePath(); ctx.fill(); break;
                case 'hip': ctx.moveTo(x, y + s); ctx.lineTo(x + s, y - s); ctx.lineTo(x - s, y - s); ctx.closePath(); ctx.fill(); break;
                case 'iliac': const currentFillStyle = ctx.fillStyle; ctx.lineWidth = Math.max(2, size / 4); ctx.beginPath(); ctx.moveTo(x - s, y); ctx.lineTo(x + s, y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x, y - s); ctx.lineTo(x, y + s); ctx.stroke(); ctx.fillStyle = currentFillStyle; break;
            }
        }
        function drawLegend(ctx, colors, canvasWidth, canvasHeight, pointSize, textColor, scaleFactor) {
            ctx.font = `${12 * scaleFactor}px Inter, sans-serif`;
            ctx.textAlign = 'left';
            const legendY = canvasHeight - (25 * scaleFactor);
            const parts = ['toe', 'mtp', 'ankle', 'knee', 'hip', 'iliac'];
            const itemWidth = 100 * scaleFactor;
            let startX = (canvasWidth - (parts.length * itemWidth)) / 2 + (20 * scaleFactor);
            parts.forEach(part => {
                ctx.fillStyle = colors[part];
                ctx.strokeStyle = colors[part];
                ctx.lineWidth = 2 * scaleFactor;
                drawMarker(ctx, part, startX, legendY, pointSize * 0.8);
                ctx.fillStyle = textColor;
                ctx.fillText(part.charAt(0).toUpperCase() + part.slice(1), startX + (15 * scaleFactor), legendY + (4 * scaleFactor));
                startX += itemWidth;
            });
        }
        function setProcessing(processing, message = '') {
            if (processing) {
                processingStatus.innerHTML = `<div class="status info p-4 rounded-md flex items-center"><div class="spinner mr-3"></div>${message}</div>`;
            } else {
                processingStatus.innerHTML = '';
            }
        }
        function showStatus(type, message) {
            fileStatus.innerHTML = `<div class="status ${type} p-4 rounded-md">${message}</div>`;
        }
        function processFile(file) {
            if (!file || !file.name.toLowerCase().endsWith('.csv')) { showStatus('error', 'Please select a CSV file'); return; }
            const reader = new FileReader();
            reader.onload = (e) => parseCSV(e.target.result);
            reader.readAsText(file);
        }
        function parseCSV(csvText) {
            try {
                setProcessing(true, 'Processing CSV file...');
                selectedFrames = [];
                const lines = csvText.split('\n').filter(line => line.trim());
                if (lines.length < 3) throw new Error("CSV must have at least 3 rows.");
                const dataLines = lines.slice(2);
                csvData = dataLines.map(line => line.split(','));
                processData();
                showStatus('success', `File loaded! ${csvData.length} frames detected. Click on the plot to select frames.`);
                downloadBtn.disabled = false;
                generateInteractivePlot();
            } catch (error) {
                showStatus('error', 'Error parsing CSV: ' + error.message);
                csvData = null;
                downloadBtn.disabled = true;
            } finally {
                setProcessing(false);
            }
        }
        function processData() {
            const threshold = parseFloat(document.getElementById('threshold').value);
            const bodyPartIndices = { 'iliac': [1, 2, 3], 'hip': [4, 5, 6], 'knee': [7, 8, 9], 'ankle': [10, 11, 12], 'mtp': [13, 14, 15], 'toe': [16, 17, 18] };
            allNormalizedPoints = csvData.map(row => {
                let points = {};
                for (const part in bodyPartIndices) {
                    const [x_idx, y_idx, l_idx] = bodyPartIndices[part];
                    if (row.length > l_idx && parseFloat(row[l_idx]) > threshold) { points[part] = { x: parseFloat(row[x_idx]), y: parseFloat(row[y_idx]) }; }
                }
                if (Object.keys(points).length < 6 || !points.iliac) return null;
                const refX = points.iliac.x, refY = points.iliac.y;
                const normalized = {};
                for (const part in points) { normalized[part] = { x: points[part].x - refX, y: points[part].y - refY }; }
                return normalized;
            });
        }
    </script>
</body>
</html>
